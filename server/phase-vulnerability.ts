import * as fs from 'fs';
import { parse } from 'csv-parse/sync';

const TOP_TARGET_GENES = ['Myc', 'Ccnd1', 'Lgr5', 'Axin2', 'Ctnnb1', 'Wnt3', 'Tp53', 'Cdkn1a', 'Bcl2', 'Bax', 'Vegfa', 'Hif1a', 'Mtor', 'Akt1', 'Pten'];
const CLOCK_GENES = ['Arntl', 'Clock', 'Per1', 'Per2', 'Per3', 'Cry1', 'Cry2', 'Nr1d1', 'Nr1d2', 'Dbp'];
const CHROMATIN_REGULATORS = ['Sirt1', 'Sirt3', 'Sirt6', 'Hdac1', 'Hdac2', 'Hdac3', 'Kat2a', 'Kat2b', 'Ep300', 'Crebbp'];

interface GeneProfile {
  gene: string;
  values: number[];
  timepoints: number[];
  mean: number;
  amplitude: number;
  peakPhase: number;
  troughPhase: number;
  peakValue: number;
  troughValue: number;
}

interface VulnerabilityWindow {
  startHour: number;
  endHour: number;
  sirt1Level: number;
  vulnerableGenes: string[];
  riskScore: number;
}

export interface PhaseVulnerabilityResult {
  sirt1Profile: GeneProfile;
  clockProfiles: GeneProfile[];
  targetProfiles: GeneProfile[];
  chromatinProfiles: GeneProfile[];
  vulnerabilityWindows: VulnerabilityWindow[];
  goldenHour: {
    phase: number;
    duration: number;
    sirt1Nadir: number;
    peakingTargets: string[];
    interpretation: string;
  };
  phaseAlignment: {
    gene: string;
    peakPhase: number;
    sirt1PhaseAtPeak: string;
    vulnerabilityScore: number;
  }[];
}

function loadDataset(filePath: string): { geneData: Map<string, number[]>; timepoints: number[] } {
  const content = fs.readFileSync(filePath, 'utf-8');
  const records = parse(content, { columns: true, skip_empty_lines: true }) as Record<string, string>[];
  
  const geneData = new Map<string, number[]>();
  let timepoints: number[] = [];
  
  if (records.length > 0) {
    const headers = Object.keys(records[0]).filter(k => k !== 'Gene' && k !== 'gene');
    timepoints = headers.map(h => {
      const match = h.match(/CT(\d+)/i) || h.match(/(\d+)/);
      return match ? parseInt(match[1]) : 0;
    });
  }
  
  for (const record of records) {
    const gene = record.Gene || record.gene || Object.values(record)[0];
    if (!gene) continue;
    
    const values = Object.entries(record)
      .filter(([key]) => key !== 'Gene' && key !== 'gene')
      .map(([, val]) => parseFloat(val))
      .filter(v => !isNaN(v));
    
    if (values.length > 0) {
      geneData.set(gene, values);
    }
  }
  
  return { geneData, timepoints };
}

function computeGeneProfile(gene: string, values: number[], timepoints: number[]): GeneProfile {
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  
  let maxVal = -Infinity, minVal = Infinity;
  let maxIdx = 0, minIdx = 0;
  
  for (let i = 0; i < values.length; i++) {
    if (values[i] > maxVal) { maxVal = values[i]; maxIdx = i; }
    if (values[i] < minVal) { minVal = values[i]; minIdx = i; }
  }
  
  const amplitude = (maxVal - minVal) / (2 * mean);
  const peakPhase = timepoints[maxIdx] % 24;
  const troughPhase = timepoints[minIdx] % 24;
  
  return {
    gene,
    values,
    timepoints,
    mean,
    amplitude,
    peakPhase,
    troughPhase,
    peakValue: maxVal,
    troughValue: minVal
  };
}

function findVulnerabilityWindows(
  sirt1Profile: GeneProfile,
  targetProfiles: GeneProfile[]
): VulnerabilityWindow[] {
  const windows: VulnerabilityWindow[] = [];
  const hourlyBins: { [hour: number]: { sirt1: number[]; peakingGenes: string[] } } = {};
  
  for (let h = 0; h < 24; h++) {
    hourlyBins[h] = { sirt1: [], peakingGenes: [] };
  }
  
  for (let i = 0; i < sirt1Profile.values.length; i++) {
    const hour = sirt1Profile.timepoints[i] % 24;
    hourlyBins[hour].sirt1.push(sirt1Profile.values[i]);
  }
  
  for (const target of targetProfiles) {
    const peakHour = Math.round(target.peakPhase) % 24;
    hourlyBins[peakHour].peakingGenes.push(target.gene);
  }
  
  const hourlyMeans: { hour: number; sirt1Mean: number; peakingGenes: string[] }[] = [];
  for (let h = 0; h < 24; h++) {
    const sirt1Vals = hourlyBins[h].sirt1;
    const sirt1Mean = sirt1Vals.length > 0 ? sirt1Vals.reduce((a, b) => a + b, 0) / sirt1Vals.length : 0;
    hourlyMeans.push({ hour: h, sirt1Mean, peakingGenes: hourlyBins[h].peakingGenes });
  }
  
  const globalSirt1Mean = sirt1Profile.mean;
  const threshold = globalSirt1Mean * 0.9;
  
  let inWindow = false;
  let windowStart = 0;
  let windowGenes: string[] = [];
  let windowSirt1: number[] = [];
  
  for (let h = 0; h < 24; h++) {
    const data = hourlyMeans[h];
    if (data.sirt1Mean < threshold) {
      if (!inWindow) {
        inWindow = true;
        windowStart = h;
        windowGenes = [];
        windowSirt1 = [];
      }
      windowGenes.push(...data.peakingGenes);
      windowSirt1.push(data.sirt1Mean);
    } else if (inWindow) {
      windows.push({
        startHour: windowStart,
        endHour: h,
        sirt1Level: windowSirt1.reduce((a, b) => a + b, 0) / windowSirt1.length,
        vulnerableGenes: [...new Set(windowGenes)],
        riskScore: windowGenes.length * (1 - windowSirt1.reduce((a, b) => a + b, 0) / windowSirt1.length / globalSirt1Mean)
      });
      inWindow = false;
    }
  }
  
  if (inWindow) {
    windows.push({
      startHour: windowStart,
      endHour: 24,
      sirt1Level: windowSirt1.reduce((a, b) => a + b, 0) / windowSirt1.length,
      vulnerableGenes: [...new Set(windowGenes)],
      riskScore: windowGenes.length * (1 - windowSirt1.reduce((a, b) => a + b, 0) / windowSirt1.length / globalSirt1Mean)
    });
  }
  
  return windows.sort((a, b) => b.riskScore - a.riskScore);
}

export function runPhaseVulnerabilityAnalysis(datasetPath: string): PhaseVulnerabilityResult {
  const { geneData, timepoints } = loadDataset(datasetPath);
  
  const sirt1Values = geneData.get('Sirt1');
  if (!sirt1Values) {
    throw new Error('SIRT1 not found in dataset');
  }
  const sirt1Profile = computeGeneProfile('Sirt1', sirt1Values, timepoints);
  
  const clockProfiles: GeneProfile[] = [];
  for (const gene of CLOCK_GENES) {
    const values = geneData.get(gene);
    if (values) {
      clockProfiles.push(computeGeneProfile(gene, values, timepoints));
    }
  }
  
  const targetProfiles: GeneProfile[] = [];
  for (const gene of TOP_TARGET_GENES) {
    const values = geneData.get(gene);
    if (values) {
      targetProfiles.push(computeGeneProfile(gene, values, timepoints));
    }
  }
  
  const chromatinProfiles: GeneProfile[] = [];
  for (const gene of CHROMATIN_REGULATORS) {
    const values = geneData.get(gene);
    if (values) {
      chromatinProfiles.push(computeGeneProfile(gene, values, timepoints));
    }
  }
  
  const vulnerabilityWindows = findVulnerabilityWindows(sirt1Profile, targetProfiles);
  
  const hourlySirt1: { [hour: number]: number[] } = {};
  for (let h = 0; h < 24; h++) hourlySirt1[h] = [];
  for (let i = 0; i < sirt1Profile.values.length; i++) {
    const hour = sirt1Profile.timepoints[i] % 24;
    hourlySirt1[hour].push(sirt1Profile.values[i]);
  }
  const hourlySirt1Mean: { [hour: number]: number } = {};
  for (let h = 0; h < 24; h++) {
    const vals = hourlySirt1[h];
    hourlySirt1Mean[h] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : sirt1Profile.mean;
  }
  
  const sirt1TroughHourMean = hourlySirt1Mean[sirt1Profile.troughPhase];
  const lowThreshold = sirt1Profile.mean * 0.85;
  const highThreshold = sirt1Profile.mean * 1.15;
  
  const phaseAlignment = targetProfiles.map(target => {
    const peakPhase = target.peakPhase;
    const peakHour = Math.round(peakPhase) % 24;
    const sirt1AtPeak = hourlySirt1Mean[peakHour];
    
    const sirt1Relative = sirt1AtPeak / sirt1Profile.mean;
    const vulnerabilityScore = target.amplitude * (1 - sirt1Relative);
    
    return {
      gene: target.gene,
      peakPhase,
      sirt1PhaseAtPeak: sirt1AtPeak < lowThreshold ? 'LOW (vulnerable)' : sirt1AtPeak > highThreshold ? 'HIGH (protected)' : 'NEUTRAL',
      vulnerabilityScore
    };
  }).sort((a, b) => b.vulnerabilityScore - a.vulnerabilityScore);
  
  const hasVulnerabilityWindow = vulnerabilityWindows.length > 0;
  const goldenHourWindow = hasVulnerabilityWindow 
    ? vulnerabilityWindows[0] 
    : {
        startHour: sirt1Profile.troughPhase,
        endHour: (sirt1Profile.troughPhase + 2) % 24,
        sirt1Level: sirt1TroughHourMean,
        vulnerableGenes: []
      };
  
  const peakingAtGoldenHour = targetProfiles
    .filter(t => {
      const start = goldenHourWindow.startHour;
      const end = goldenHourWindow.endHour;
      if (start < end) {
        return t.peakPhase >= start && t.peakPhase <= end;
      } else {
        return t.peakPhase >= start || t.peakPhase <= end;
      }
    })
    .map(t => t.gene);
  
  const sirt1SD = Math.sqrt(sirt1Profile.values.reduce((acc, v) => acc + Math.pow(v - sirt1Profile.mean, 2), 0) / sirt1Profile.values.length);
  const troughEffectSize = (sirt1Profile.mean - sirt1TroughHourMean) / sirt1SD;
  
  const windowDuration = goldenHourWindow.endHour > goldenHourWindow.startHour 
    ? goldenHourWindow.endHour - goldenHourWindow.startHour 
    : 24 - goldenHourWindow.startHour + goldenHourWindow.endHour;
  
  return {
    sirt1Profile,
    clockProfiles,
    targetProfiles,
    chromatinProfiles,
    vulnerabilityWindows,
    goldenHour: {
      phase: goldenHourWindow.startHour,
      duration: windowDuration,
      sirt1Nadir: goldenHourWindow.sirt1Level / sirt1Profile.mean,
      peakingTargets: peakingAtGoldenHour,
      interpretation: `HYPOTHESIS: The "Golden Hour" at CT${goldenHourWindow.startHour}-${goldenHourWindow.endHour} corresponds to SIRT1 trough (${((goldenHourWindow.sirt1Level / sirt1Profile.mean) * 100).toFixed(1)}% of mean, effect size=${troughEffectSize.toFixed(2)}Ïƒ). ${peakingAtGoldenHour.length > 0 ? `Genes peaking in this window (${peakingAtGoldenHour.join(', ')}) may be more susceptible to epigenetic dysregulation.` : 'No Top 10 targets peak during this window.'} This suggests a potential intervention window for SIRT1-modulating compounds, pending experimental validation.`
    },
    phaseAlignment
  };
}
